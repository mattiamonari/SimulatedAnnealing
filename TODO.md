1. Define the Problem

    Input: A set of cities with distances between each pair.
    Output: The shortest possible route that visits every city exactly once and returns to the starting point.

2. Represent a Solution

    Represent the solution as a permutation of cities. For example, if there are cities A, B, C, D, a possible solution is [A, C, D, B, A].

3. Initialize the Algorithm

    Generate an Initial Solution
    Start with a random permutation of cities.

    Set Initial Parameters
        Temperature (T): Start with a high temperature.
        Cooling Rate (α): A value between 0 and 1 (e.g., 0.95).
        Stopping Criteria: Minimum temperature or a maximum number of iterations.

    Objective Function
    Calculate the total distance of the route (sum of distances between consecutive cities).

4. Define the Neighboring Solutions

    A neighbor is generated by slightly modifying the current solution. Common techniques include:
        Swap: Randomly swap two cities.
        Reversal: Reverse the order of cities between two random indices.
        Insertion: Remove a city and reinsert it at another random position.

5. Implement the Acceptance Criteria

    Calculate the cost (route length) of the current solution and the neighbor solution.
    If the neighbor is better (shorter route), accept it.
    If the neighbor is worse:
        Accept it probabilistically using the formula:
        P=e−Δ/T
        P=e−Δ/T Where ΔΔ is the increase in distance, and TT is the current temperature.

6. Update the Temperature

    Gradually reduce the temperature using the cooling schedule:
    T=α⋅T
    T=α⋅T

7. Repeat Until Stopping Criteria

    Iterate through steps 4–6 until:
        The temperature TT is below a threshold, or
        A maximum number of iterations is reached.

8. Output the Best Solution

    Track the best solution found during the process.
    Return this solution as the approximate shortest route.

Pseudo-code

```
initialize_solution()
initialize_temperature(T)
best_solution = current_solution

while T > stopping_temperature:
    for i in range(max_iterations):
        neighbor = generate_neighbor(current_solution)
        delta = cost(neighbor) - cost(current_solution)

        if delta < 0 or random() < exp(-delta / T):
            current_solution = neighbor
            if cost(current_solution) < cost(best_solution):
                best_solution = current_solution
    
    T *= cooling_rate  # Reduce temperature

return best_solution
```

TODO: 
1. Plot best permutation for each cooling scheme
2. Draw boxplots for each cooling scheme
3. Other exercises